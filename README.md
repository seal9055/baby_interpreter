## Rust-based Bytecode-Interpreter for JS-subset

-----------------------------------------------------------------------------------------------

This interpreter uses a 4 stage interpretation pipeline to go from source code to actually
executing code.  

1. Lexer:  
	In this phase the initially provided source code is split up into a series of tokens. These  
	tokens contain information about the source code line from which the token was retrieved  
	(debug purposes), the name of the token, and the actual data.

	![Lexer](https://github.com/seal9055/baby_interpreter/blob/main/imgs/lexer.png)

2. Parser:  
	This phase takes in the token stream generated by the lexer and actually adds some structure to it.  
	It uses a recursive descent parser to iterate through the tokens and generate an Abstract Syntax Tree.  

	![Parser](https://github.com/seal9055/baby_interpreter/blob/main/imgs/parser.png)

3. Codegen:  
	This phase takes in an AST and uses it to generate bytecode. This bytecode is fairly similar to assembly,  
	but it allows for a couple of higher level operations (such as adding 2 strings). The generated bytecode  
	instructions operate on virtual registers (this means there is no limit on the amount of useable registers),  
	apart from r0, which is reserved for function return values. This phase is also responsible for determining  
	the entrypoint, generating a constant pool that contains all strings found within the program so they do not  
	have to be stored within the bytecode itself, and a list of functions with their corresponding offsets.

	![Codegen](https://github.com/seal9055/baby_interpreter/blob/main/imgs/bytecode.png)

4. Interpreter:  
	This final stage takes in the bytecode alongside some other necessary information provided by the Codegen  
	phase and uses it to actually execute the code. This is done via a register based vm.  

You can enable the debug options to receive the above outputs view globals defined in src/main.rs. The /testing  
folder has some more code examples if you wish to see what else the interpreter is capable off.  

This interpreter supports all common primitive types (Numbers, Strings, Booleans), and common operations on them.  
It also supports variables and control flow via if/else statements, while loops and functions. These can be recursive,  
however, closures are not yet supported. I may add them in the future including some other additions such as  
optimizations during code generation, support for arrays, and some more builtins apart from just console.log().  
